#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Тарпанов Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |        4      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Выписать грамматику запросов (в явном виде). Словари лучше построить более гибко (им.падеж имени: соответствующие словоформы).

## Введение
В обработке естественных языков зачастую используются два метода: лингвистический и статистический. Лингвистический подход основан на лингвистическом анализе, который проходит в 4 этапа: графематический (отдельные слова), морфологический, синтаксический (зависимости слов в предложениях) и семантический (смысл целого высказывания). Статистический же анализ состоит в предположении о том, что смысл текста отражается наиболее часто встречающимися словами.

Задачи обработки естественных языков достаточно удобно решать с помощью средств языков логического программирования. Это связано с простотой и естественностью реализации процесса переборов с возвратами, а также удобством манипулирования символьной информацией.

Пролог обладает большими возможностями по сопоставлению объектов с эталоном. В интерпретаторе Пролога по умолчанию принята стратегия решения задач с обратным ходом решения. Т.е. решение начинается с запроса, которое разбивается на подцели правила, далее делится на еще более мелкие составные части и т.д. На ней же базируется и система нисходящего грамматического разбора. Поэтому реализаця такого разбора на Прологе осуществляется достаточно прямолинейным способом.

## Задание

Генеалогическое дерево задано фактами вида:
```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).
...
```
Написать программу на Прологе, которая будет отвечать на запросы о родстве.
Составить словарь имен(4-5) и степеней родства(4-5).
## Принцип решения
Исходное дерево с фактами:
```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).
parent(tolia, sveta).
```
Для начала создаются словари имен и их форм, степеней родства, а так же словарь вопросов: 
```prolog
tolia(tolia).
tolia(tolin).
tolia(toli).

alexei(alexei).
alexei(alexeia).

volodia(volodia).
volodia(volodin).
volodia(volodi).

tima(tima).
tima(timi).
tima(timin).

sveta(sveta).
sveta(sveti).
sveta(svetin).

brat(brat).

otec(otec).

sestra(sestra).

my_sin(sin).

doch(doch).

chei(chia).
chei(chei).
kto(kto).
```
Потом необходимо описать предикат, приводящий имя к форме, приведенной в фактах генеалогического дерев: 
```prolog
imenit_padej(X, Y) :-
    tolia(X), Y = tolia, !;
    sveta(X), Y = sveta, !;
    volodia(X), Y = volodia, !;
    tima(X), Y = tima, !;
    alexei(X), Y = alexei.
```
Теперь можно описать предикаты родства: 
```prolog
male(X) :-
    not(sveta(X)).

brother(X,Y) :-
    parent(Z,X),
    parent(Z,Y),
    male(X),
    X \= Y, !.

sister(X, Y) :-
    parent(Z, X),
    parent(Z, Y),
    not(male(X)),
    X \= Y, !.

father(X, Y) :-
    parent(X, Y),
    male(X), !.

son(X, Y) :-
    parent(Y, X),
    male(X), !.

daughter(X, Y) :-
    parent(Y, X),
    not(male(X)), !.    
```
Получили необходимые предикаты для определения родства. После этого опишем предикаты, позволяющие обрабатывать запросы:
```prolog
familiarity(X):-
    brat(X), !;
    sestra(X), !;
    otec(X), !;
    doch(X), !;
    my_sin(X).

familiarity_request(A, B, C) :-
    brat(C), brother(A, B), !;
    sestra(C), sister(A, B), !;
    otec(C), father(A, B), !;
    my_sin(C), son(A, B), !;
    doch(C), daughter(A, B).

question(X) :-
    chei(X), !;
    kto(X).

my_name(X) :-
    tolia(X), !;
    volodia(X), !;
    sveta(X), !;
    tima(X), !;
    alexei(X).
```
Предикат familiarity() проверяет, является ли указанное слово какой-либо формой родства. Похожим образом работают предикаты question() и my_name(): первый определяет, является ли слово вопросительным местоимением, второй определяет, является ли слово именем. Предикат familiarity_request() определяет степень родства для двух имен и формы родства из запроса. Все вышеописанные предикаты позволяют написать главный предикат, который будет анализировать запрос и выдавать на него ответ:
```prolog
parse([A, B, C, D], R) :-
    my_name(A), familiarity(B), my_name(C), imenit_padej(A, G), imenit_padej(C, E), familiarity_request(G, E, B), R = yes, !;
    my_name(A), familiarity(B), my_name(C), imenit_padej(A, G), imenit_padej(C, E), not(familiarity_request(G, E, B)), R = no, !;
    question(A), my_name(B), familiarity(C), kto(A), imenit_padej(B, E), familiarity_request(X, E, C), R = X, !;
    question(A), familiarity(B), my_name(C), kto(A), imenit_padej(C, E), familiarity_request(X, E, B), R = X, !;
    question(A), familiarity(B), my_name(C), chei(A), imenit_padej(C, E), familiarity_request(E, X, B), R = X.
```
В предикате parse() рассмотрены разные вариантов запросов. После определения варианта происходит преобразование имени к именительному падежу и запрос на форму родства.
## Результаты
```prolog
?- parse([tolin,brat,volodia,?],X).
X = yes.

?- parse([volodia,brat,toli,?],X).
X = yes.

?- parse([kto,otec,toli,?],X).
X = alexei.

?- parse([kto,sin,toli,?],X).
X = tima.

?- parse([kto,doch,toli,?],X).
X = sveta.

?- parse([kto,sestra,timi,?],X).
X = sveta.

?- parse([chia,sestra,sveta,?],X).
X = tima.

?- parse([chei,otec,tolia,?],X).
X = tima.

```
## Выводы

Я реализовал достаточно несложный фрагмент естественно-языкового интерфейса, позволяющий делать запросы по дереву родства. Для его работы пришлось создать словари, что, как мне кажется, не самая лучшая идея. Дело в том, что код моей программы очень сложно поддерживать и менять. Большая часть предикатов построена исходя из того, что словарь имен ограничен и заранее известен. Для того, чтобы добавить новый факт в дерево, понадобится поменять много предикатов. Хорошей идеей было бы реализовать морфологическую обработку слов. Такой метод позволил бы отказаться от некоторых словарей, но все ещё не привел бы к существенному упрощению предикатов. Вообще говоря, дальнейшее усовершенствование моей программы является заданием курсового проекта, и, очевидно, не настолько просто, как эта лабораторная работа. Поэтому, я решил реализовать данную лабораторную работу самым нативным методом.
Также, хочется сказать, что Пролог, безусловно, мощный инструмент для грамматического и синтаксического разбора. Он предлагает совершенно иные возможности для написания программ, нежели популярные императивные и функциональные языки программирования. Из минусов решения подобных задач искусственного интеллекта можно выделить тот факт, что для их решения требуется некоторая база данных, которую приходится набивать руками.




