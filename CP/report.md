# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Тарпанов Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |     5          |
| Левинская М.А.|              |               |

> *Код местами нуждается в оптимизации*

## Введение

Выполнив данный курсовой проект, я получил следующие навыки и знания: 

1) Познакомился с понятием информационных систем, посмотрел на применение языков логического программирования при их создании. Также, очень важно для меня было то, что впервые за долгое время я писал осмысленный текст. Первые пару часов слова не лезли в голову от непривычки, но потом навыки и знания, которые я не использовал со времен ЕГЭ начали возвращаться и получился достаточно неплохой текст.

2) Углубил свои знания языка программирования Prolog. Этот курсовой проект использовал все навыки, полученные мной из лабораторных работ в еще большей степени, в связи с чем у меня получилось учесть свои прошлые ошибки и написать более качественный код.

3) Для составления генеалогического дерева я обзонил множество родственников, с каждым из которых предварительно пообщался о жизни. Не знаю, стоит ли это писать здесь, но я очень давно не заниался такими вещами.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: предикаты `father(отец, потомок)` и `mother(мать, потомок)`.
 3. Реализовать предикат проверки/поиска шурина.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева
Я зарегестрировался на сайте MyHeritage.com, после чего, используя телефонную связь, обзвонил родственников и составил свое дерево. В моем дереве представлены 4 поколения, в которых суммарно получилось 47 человек. Стоит отметить, что по условию мне необходимо использовать предикаты father и mother, что не определяет пол людей, у которых нет детей. Поэтому, каждому человеку без реальных детей был добавлен лист NULL, чтобы записать предикат родства.

## Конвертация родословного дерева
Создав свое генеалогическое дерево и экспортировав его в формате GEDCOM, мне было необходимо выбрать язык программирования, на котором я буду парсить. Выбирал я из следующего списка: Prolog, Python, C++ и bash. Первый и последний язык я отбросил достаточно быстро, так Пролог я на тот момент знал плохо, а bash, честно говоря, совсем неудобен для решения подобных задач. Выбирая из С++ и Python, я склонился ко второму, так как у меня еще не было опыта работы с ним и мне хотелось попробовать чего-нибудь нового. Бегло изучив синтаксис, я решил воспользоваться коронной особенностью питона: наличием библиотек на любую тему. Безусловно, библиотека, выполняющая синтаксический разбор файла формата GEDCOM очень легко нашлась и сделала основную работу. Идея такова: с помощью библиотечной функции находим список всех детей, а потом для каждого ребенка из списка находим его родителей и выводим в файл.
В целом, эта часть задания оказалась достаточной интересной и, честно говоря, удивительной, так как я впервый столкнулся с таким простым использованием чужого кода на достаточно странную и непопулярную тему.

## Предикат поиска родственника
Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы).
Мне нужно было реализовать предикат для поиска/проверки шурина. Шурин - родной брат жены. Исходный код:
```prolog
brotherInLaw(Man, Bil) :-
    father(Man, Child),
    Child \= 'NULL ',
    mother(Mother, Child),
    father(Fil, Mother),
    father(Fil, Bil),
    father(Bil,_),
    Bil \= Mother, !.
```
Реализация получилась абсолютно нативной. Будем считать, что если у двух людей в дереве есть общие дети, то они женаты. Тогда для мужчины, которому мы ищем шурина, определим сначала жену. Потом найдем отца жены, и от отца найдем ребенка. Также, проверим, что найденный ребенок приходится кому-то отцом (имеет мужской пол).
Результат работы предиката: 
```prolog
?- brotherInLaw(X,Y).
X = 'Александр Иваневский',
Y = 'Александр Тарпанов'.
```
Больше результатов нет, так как во всем моём дереве есть только два человека, между которым есть подобное родство.
## Определение степени родства

Определение степени родства оказалось достаточно интересной задачей. Для её решения я использовал поиск в ширину. Для реализации поиска в ширину нужен предикат prolog, был описан мной следующим образом:

```prolog
male(X) :-
    father(X,_).
female(X) :-
    mother(X, _).

relative_link(father, Father, X) :-
    father(Father, X),
    X \= 'NULL '.
relative_link(mother, Mother, X) :-
    mother(Mother, X),
    X \= 'NULL '.
...
relative_link(sibling, Child1, Child2) :-
    father(X, Child1),
    father(X, Child2).
link(X) :-
    member(X, [father, mother, son, daughter, husband, wife, brother, sister]).
move(X, Y) :-
    relative_link(_, X, Y),
    Y \= 'NULL '.
prolong([X|T], [Y, X|T]) :-
    move(X,Y),
    not(member(Y, [X|T])).

```
Я реализовал предикат relative_link, проверяющий родство двух людей. Получился следующий список вариантов родства: отец, мать, сын, дочь, муж, жена, брат, сестра. Также, для задания №5 были реализована проверка на сиблинга и ребенка. Потом, используя этот предикат, я написал предикат move, который просто находит следующего человека для цепочки родственников. Этот все было необходимо для предиката prolong, который прокладывает путь и проверяет, что он не зацикливается. Потом я написал классический поиск в ширину и перевод цепочек имен в цепочки родства:

```prolog
breadth_search(Start, Finish, Result):-
	breadth([[Start]], Finish, Way),
    reverse(Way, Result).

breadth([[Finish | Tail] | _], Finish, [Finish | Tail]).
breadth([TempWay | OtherWays], Finish, Way):-
	findall(W, prolong(TempWay, W), Ways),
	append(OtherWays, Ways, NewWays),
	breadth(NewWays, Finish, Way).

names_to_relations([_], []) :- !.
names_to_relations([First, Second|Tail], Result) :-
    relative_link(Relation, First, Second),
    Result = [Relation | RecursiveRes],
    names_to_relations([Second|Tail], RecursiveRes), !.

relative(X, Y, Result) :-
    breadth_search(X,Y, TempRes),
    names_to_relations(TempRes, Result).
```
При необходимости можно легко изменить код, чтобы посмотреть цепочку по именам, а не по родству, чтобы понять по какому именно пути шел предикат. Результат работы программы:
```prolog
?- relative('Даниил Тарпанов','Инна Дацко',X).
X = [son] ;
X = [son, husband] ;
X = [brother, daughter] ;
X = [son, father, daughter] ;
X = [brother, daughter, husband] ;
```
На самом деле, программа выводит много повторяющихся ответов, но я убрал их из вывода, чтобы было легче читать. Это связано со свойствами поиска в ширину.

## Естественно-языковый интерфейс

Естественно-языковой интерфейс для меня был самым сложным заданием курсового проекта. Как нам было сказано на консультации, использование строгих шаблонов оценивается не очень высоко, в связи с чем я решил усовершенствовать модель шаблонов, но не отказываясь от нее полностью. Идея такова: сначала напишем преобразователь цепочек родства для того, чтобы программа могла отвечать на вопросы типа "Who is Vasya's mother's sister?", то есть, чтобы программа могла найти человека, который является сестрой матери Васи, и потом уже отвечать на вопрос про этого человека. Вот реализация такого предиката:
```prolog
chain_helper(X, [], Result) :-
    Result = X,!.
chain_helper(X, [TempRelative], Result) :-
    to_single_form(TempRelative, Relative),
    relative_link(Relative, Result, X),!.
chain_helper(X, [TempRelative|Tail], Result) :-
    to_single_form(TempRelative, Relative),
    relative_link(Relative, Y, X),
    chain_helper(Y, Tail, Res),
    Result = Res, !.

chain(X, Chain, Result) :-
    chain_helper(X, Chain, Result).
```
Теперь часть, которую я заимствовал из шаблонов. Мой предикат, анализирующий предложения, основывается на том, что допустимы 4 типа вопросов: 
1) Who X's Y?

2) Does X have Y?

3) Is X Y's Z?

4) How much X has Y?

Для каждого из этих типов написан отдельный предикат, разбирающий вопрос. В целом, сначала выделяются имена с цепочками (при наличии этих самых цепочек), потом цепочки раскрываются и происходит проверка связи между двумя конечными людьми. Стоит сказать, что предикат принимает на вход список, где каждое слово является атомом, и все слова кроме имен начинаются с маленкой буквы. Примеры работы предиката: 
```prolog
?- analysis([is, 'Александр Тарпанов',"'s", son, 'Ева Тарпанова',"'s", brother]).
Yes
true.

?- analysis([how, much, sisters, he, has]).
Даниил Тарпанов has 1 sisters:
[Ева Тарпанова]
true.

?- analysis([does, 'Александр Тарпанов', have, children]).
Yes.
true.


?- analysis([who, is, his, child]).
Даниил Тарпанов is Александр Тарпанов's child
true.
```
Стоит отметить странное смешение русских имен и английских предложений. Когда я делал дерево, я не особо задумывался о том, что мне предстоить делать в самом курсовом, и поэтому все имена написаны на русском языке. Английский язык для вопрос я выбрал потому, что его гораздо легче обрабатывать.
## Выводы
В целом, эта курсовая работа оказалось самой интересной для меня за всё время обучения в МАИ. И дело не в том, что мне очень понравился Prolog как язык программирования. Все курсовые работы до этой были очень шаблонными и бытовыми, нужно было просто решить задание и скопировать эссе. Здесь же, я полностью самостоятельно написал реферат, а также обработчик естественного языка, потому что к нашему обучению был приложен немного другой подход. Теперь стоит похвалить и поругать свой код. К минусам я могу отнести не слишком уж свободный естественно-языковой интерфейс. Есть много вещей, которые можно было бы поменять и улучшить. Также, поиск в ширину в четвертом задании выводит повторяющиеся цепочки, чего тоже можно было бы избежать. Еще одной проблемой поиска в ширину является то, что если выбирать родственников на более-менее приличном расстоянии друг от друга программа начинает работать сильно дольше и иногда происходит переполнение стека. Хочется отметить, что при работе с этим курсовым проектом я использовал все навыки, полученные мной из лабораторных работ, что, на самом деле, создаёт интересную интеграцию элементов курса. 
