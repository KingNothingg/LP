# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Тарпанов Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Говоря о списках, любой программист, программировавший до этого на традиционных языках, представляет структуру данных, в которой зачастую хранятся элементы одного типа, к коим легко обращаться по итераторам. В Прологе всё не так. В этом языке списки могут хранить в себе элементы различных типов, да и обращаться к ним по простому не получится. Обращение к элементам, в связи с особенностями языка, осуществляется рекурсивно, разделяя список на голову и хвост. Эта особенность сильно меняет привычные методы работы со списками.
Если сравнивать списки в Прологе с структурами данных в других языках, можно сказать, что они больше всего похожи на бинарные деревья, в листьях которых находятся либо элементы списка, либо пустые списки. То есть список либо пуст, либо состоит из двух элементов: головы и хвоста, который, в свою очередь, сам является списком.

## Задание 1.1: Предикат обработки списка

`my_remove_last(L, R)` - предикат, удаляющий последний элемент списка, не используя стандартных предикатов. `my_remove_last_std(L, R)` - удаляет последний элемент списка, используя стандартные предикаты.

Примеры использования:
```prolog
?- my_remove_last([1,2,3,5,9], X).
X = [1, 2, 3, 5] .
?- my_remove_last([10], X).
X = [] .
?- my_remove_last([], X).
false.
?- remove_last_std([10], X).
X = [] .
?- remove_last_std([], X).
false.
?- remove_last_std([1,2,3,5,9], X).
X = [1, 2, 3, 5] .
```

Реализация без использования стандартных предикатов:
```prolog
my_remove_last([X], []).
my_remove_last([L|T], [L|R]) :- my_remove_last(T,R). 
```
Реализация без использования стандартных предикатов рекурсивна, следовательно, необходимо условие выхода из рекурсии. Очевидно, что если список состоит из одного элемента, то результат работы предиката превратит его в пустой список. Пользуясь этим правилом, рекусивная реализация реализация проходит проходит по списку, отбрасывая головы, пока не дойдет до списка, состоящего из одного элемента. После этого, она превратит этот список в пустой, и, возвращаясь из рекурсии, вернет все отброшенные головы на место.


Реализация с использованием стандартных предикатов:
```prolog
remove_last_std(L,R) :- append(R, [X], L).
```
Реализация с использованием предиката append работает следующим образом: для исходного списка L сопоставляется список R, добавив в который один элемент получится список L. Этим списком будет сам список L, но без последнего элемента.

## Задание 1.2: Предикат обработки числового списка

`is_ascending(S)` - предикат, определяющий , является ли последовательность элементов списка возрастающей без использования стандартных предикатов. `is_ascending_std(S)` - предикат, определяющий, является ли последовательность элементов списка возрастающей, используя стандартные предикаты. 

Примеры использования:
```prolog
?- is_ascending([1,2,3,4,5]).
true.
?- is_ascending([1,2,3,4,3,5,6,7]).
false.
?- is_ascending([1]).
true.
?- is_ascending_std([4,5,6,9]).
true.
?- is_ascending_std([4,5,6,9,1]).
false.
?- is_ascending_std([0,6,9,9]).
false.
```

Реализация без использования стандартных предикатов:
```prolog
is_ascending([T,H|R]):- 
    !, 
    T < H,
    is_ascending([H|R]). 
is_ascending(_).
```
Реализация без использования стандартных предикатов рекурсивна, так как нужно просмотреть все элементы списка. Отрезается голова из двух элементов, в случае, если первый больше либо равен второму, операцией отсечения заканчивается рекурсия и возвращается значение false. Иначе попарно сравниваются все остальные элементы.

Реализация с использованием стандартных предикатов:

```prolog
is_ascending_std([T|H]) :-
    length(H,L),
    L =\= 0,
    member(Y,H),
    !,
    T < Y,
    is_ascending_std(H).
is_ascending_std(_).
```
Реализация с использованием предикатов member и length выглядит немного странней, чем реализация без стандартных предикатов. Идея почти такая же, однако в качестве головы берется лишь один элемент, а после этого, если длина хвоста не равна нулю, из него функцией member достается следующий.

## Задание 2: Реляционное представление данных

Реляционное представление данных связывает связывает объекты между собой, а задачей программиста в таком случае является их анализ. Взаимодействие с такими данными осуществляется с помощью запросов, на которые программа должна выводить ответы, соответсвующие внутренней структуре программы. Задачей программиста является написать такую программу, которая будет выводить правильные ответы на необходимые вопросы. Удобство такого представления в том, что программу можно "собирать по частям", отлаживая каждую часть отдельно.
Представление конкретно моего варианта оказалось достаточно удобным, в сравнении с другими, просмотренными мной. Так как данные представлены в структуре с четырьмя полями, анализ с помощью предиката findall получился очень простым. Единственной проблемой оказалось то, что в случае поиска количества несдавших студентов для группы, в некоторых ситуациях выводилось некорректное число. Это связано с тем, что считались все неудовлетворительные оценки студента. Однако такая проблема легко решается переводом списка студентов-двоечников в множество.

Примеры использования:
```prolog
?- do_not_passed_group().
Количество студентов в группе, не сдавших предмет:
102 - 5
101 - 2
104 - 2
103 - 3
false.
?- do_not_passed_sub().
Количество студентов, не сдавших предмет:
Логическое программирование - 2
Математический анализ - 3
Функциональное программирование - 1
Информатика - 2
Английский язык - 4
Психология - 1
false.
?- average_grade().
Средние оценки:
Логическое программирование - 3.9642857142857144
Математический анализ - 3.892857142857143
Функциональное программирование - 3.9642857142857144
Информатика - 3.9285714285714284
Английский язык - 3.75
Психология - 3.9285714285714284
false.

``` 
Реализация печати среднего балла для каждого предмета:

```prolog
%сумма всех элементов списка.
summ_of_list_elements([X],X).
summ_of_list_elements([X|T], N) :- summ_of_list_elements(T, N1), N is N1 + X. 

%подсчет средней оценки по предмету
average_grade_sub(Sub, X) :-
    findall(Grade, grade(_,_,Sub,Grade), List),
    summ_of_list_elements(List, Summ),
    length(List, Count),
    X is Summ / Count.

%получение списка предметов
get_sub_list(S) :-
    findall(Y, grade(_,_,Y,_), L),
    list_to_set(L, S).

%вывод средней оценки по предмету
print_average_grades([S|T]) :-
    average_grade_sub(S,X),
    write(S), write(' - '), write(X), write('\n'),
    print_average_grades(T).
%вывод средних оценок по всем предметам
average_grade() :-
    get_sub_list(S),
    write('Средние оценки:\n'),
    print_average_grades(S).
``` 
Для вывода средней оценки по каждому предмету, в первую очередь, необходимо знать сами предметы. Для этого предикатом findall находится список предметов, однако, так как записей об оценках много, и у каждого студента есть эти предметы, получается большой список с кучей повторений. В Прологе есть встроенный предикат list_to_set, который переводит список в множество. Множество это структура, содержащая в себе список уникальных объектов. Таким образом происходит избавление от дубликатов в списке. После этого все оценки по предмету находятся с помощью findall и суммируются предикатом summ_of_list_elements. Этот предикат рекурсивно прибавляет голову к результату, и продолжает делать прибавления уже для хвоста. Происходит это до момента, когда в списке не останется один элемент. В этом случае сумма будет равна этому элементу. После получения суммы, используется предикат length и находится длина списка. Средней оценкой будет результат деления суммы оценок на их количество. Эта средняя оценка выводится, и продолжается вычисление для следующего предмета.

Реализация печати количества несдавших студентов для группы:

```prolog
%Получение списка групп
get_group_list(S) :-
    findall(Y, grade(Y,_,_,_), L),
    list_to_set(L,S).

%Вывод количества несдавших несдавших студентов для группы
print_quantity_of_not_passed_students_group([H|T]):-
    findall(Y, grade(H,Y,_,2), L),
    list_to_set(L, R),
    length(R, N),
    write(H), write(' - '), write(N), write('\n'),
    print_quantity_of_not_passed_students_group(T).

%Вывод для всех групп
do_not_passed_group() :-
    get_group_list(S),
    write('Количество студентов в группе, не сдавших предмет:\n'),
    print_quantity_of_not_passed_students_group(S).
```
Чтобы вывести количество несдавших студентов для каждой группы, необходимо знать сами группы. Для этого предикатом findall получатся список групп, который переводится в множество. После, этим же предикатом находятся список студентов, не сдавших хотя бы один предмет. Так как один студент может не сдать несколько предметов, необходимо также перевести список в множество. Следующим действием выводится количество элементов этого множества и происходит рекурсивный вызов предиката для следующей группы.

Реализация печати количества студентов, несдавших предмет:

```prolog
%получение списка предметов
get_sub_list(S) :-
    findall(Y, grade(_,_,Y,_), L),
    list_to_set(L, S).
    
%Вывод количества студентов, не сдавших предмет
print_quantity_of_not_passed_students_sub([H|T]) :-
    findall(X, grade(_,X,H,2), L),
    length(L, N),
    write(H), write(' - '), write(N), write('\n'),
    print_quantity_of_not_passed_students_sub(T).

%Вывод для каждого из предметов
do_not_passed_sub() :-
    get_sub_list(S),
    write('Количество студентов, не сдавших предмет:\n'),
    print_quantity_of_not_passed_students_sub(S).
```

Реализация данного запроса очень похожа на реализацию запроса вывода количества несдавших студентов для групп: находится список предметов, преобразуется в множество, находятся студенты, не сдавшие предмет, происходит вывод.

## Выводы

Эта лабораторная работа стала моим первым опытом полноценного программирования на Прологе. В связи с этим, первые несколько часов выполнения лабораторной поломали мой мозг. Я, как человек, привыкший к императивному программированию, очень долго пытался понять, как реализовывать простейшие предикаты для первого задания. Казалось бы, всего пара строчек. Однако в сравнении с привычными мне реализациями методов на традиционных языках эта пара строчек в разы мощней. Связано это с тем, что предикаты обработки списков в основном выполняются рекурсивно, а продумать рекурсию неискушенному человеку достаточно трудно. Просмотрев несколько примеров, у меня начало получаться. Разобравшись с первым заданием я перешел ко второму. К моему удивлению, оно оказалось не таким сложным. В сравнении с первым заданием, где нужно представлять разнообразные действия, во втором нужно было лишь перебирать элементы списка. Остальное за меня сделали утилиты findall и list_to_set. Подводя итоги, могу сказать, что после выполнения этой лабораторной работы, у меня появилось ясное ощущение того, что использование рекурсии это своего рода искусство. Итеративные методы, применяемые в традиционных языках, в Прологе недоступны. Поэтому, для выполнения задания мне пришлось придти к новому пониманию написания кода и вообще к новой фундаментальной структуре -- логическому программированию.




