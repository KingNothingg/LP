#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Тарпанов Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Пространство состояний представляет собой набор ситуаций. Из каждого состояния возможно перейти в другое состояние путем каких-то действий. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния -- начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе. Основные стратегии решения такой задачи, которые я использовал в своей работе, -- поиск в глубину, поиск в ширину и поиск с итеративным погружением.
Для представление графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

## Задание

Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

Для решения задачи необходимо описать набор переходов между состояниями. В данной задаче есть условие, исходя из которого нельзя оставлять миссионеров в меньшенстве. Напишем предикат, который будет определять, удовлетворяет ли переход этому условию:
```prolog
count_k(L, N):-
	delete(L, 'm', L1),
	length(L1, M), N is M.

count_m(L, N):-
	delete(L, 'k', L1),
	length(L1, M), N is M.

balance(L):-
	count_m(L, X),
	count_k(L, Y),
	(X >= Y; X == 0).
```
Для реализации предиката balance были написаны предикаты count_k и count_m, которые подсчитывают количество каннибалов и миссионеров соответсвенно в списке. Далее необходимо описать сами правила переходов. Перед этим, хотелось бы рассказать про структуру состояния. Состояние представляет собой количество каннибалов и миссионеров на каждом из берегов, а также принадлежность лодки к какому-либо берегу. Миссионеры и каннибалы обозначаются буквами m и k соответсвенно, а лодка обозначается буквой b. Состояние будет реализовано в виде двух списков, в которых будет информация о левом и правом береге. Таким образом, начально состояние выглядит так:
```prolog
[[k,k,k,m,m,m,b],[]]
```
Теперь можно описать предикаты, осуществляющие переходы между состояниями:
```prolog
%KM->
move([LCoast, RCoast], [NewLCoast, NewRCoast]) :-
    member(b, LCoast),
    delete(LCoast, b, TempLCoast),
    append(Head, [k, m |Tail],TempLCoast),
    append(Head, Tail, SecTempLCoast),
    append(RCoast, [k, m, b], TempRCoast),
    sort_items(SecTempLCoast, NewLCoast),
    sort_items(TempRCoast, NewRCoast),
    balance(NewLCoast),
    balance(NewRCoast).
```
Выше приведен предикат, перемещающий каннибала и миссионера с левого берега на правый. Стоит отметить, что переходов достаточно много и полный список предикатов приведен в файле solution.pl. После описания всех переходов можно написать предикат prolong, который будет продлевать путь:
```prolog
prolong([OldState | States], [NewState, OldState | States]) :-
    move(OldState, NewState),
    not(member(NewState, [OldState | States])).
```
Отмечу, что состояния хранятся списком, чтобы можно было определить путь.
Теперь, необходимо реализовать предикаты самого поиска. 
```prolog
depth([Finish | States], Finish, [Finish | States]).
depth(CurrState, Finish, Ways) :-
    prolong(CurrState, NewWay),
    depth(NewWay, Finish, Ways).

depth_search(Start, Finish):-
  get_time(DFSStart),
	depth([Start], Finish, Way),
	print_way(Way),
  print_answer(Way),
  get_time(DFSEnd),
  nl,
  Time is DFSEnd - DFSStart,
  write('Time is '), write(Time), nl.
  print_way([_]).
  
print_way([_, B | Tail]):-
	print_way([B | Tail]),
	nl,
	write(B).
	
print_answer([A | _]):-
	nl,
	write(A),
	nl.

breadth_search(Start, Finish):-
  get_time(BFSStart),
	breadth([[Start]], Finish, Way),
	print_way(Way),
	print_answer(Way),
  get_time(BFSEnd),
  nl,
  Time is BFSEnd - BFSStart,
  write('Time is '), write(Time), nl.

breadth([[Finish | Tail] | _], Finish, [Finish | Tail]).
breadth([TempWay | OtherWays], Finish, Way):-
	findall(W, prolong(TempWay, W), Ways),
	append(OtherWays, Ways, NewWays),
	breadth(NewWays, Finish, Way).

int(1).
int(N):- int(M), N is M + 1.

iter_search(Start, Finish):-
  get_time(IterStart),
	int(Level),
	(
		Level > 100, !;
		id([Start], Finish, Way, Level), print_way(Way), print_answer(Way)
  ),
  get_time(IterEnd), nl,
  Time is IterEnd - IterStart,
  write('Time is '), write(Time), nl.

id([Finish | Tail], Finish, [Finish | Tail], 0).
id(TempWay, Finish, Way, N):-
	N > 0,
	prolong(TempWay, NewWay),
	N1 is N - 1,
	id(NewWay, Finish, Way, N1).
```
Выше приведены предикаты поиска. depth_search -- поиск в глубину, breadth_search -- поиск в ширину, iter_search -- поиск в глубину с итеративным погружением.  Каждый из них основывается на вспомогательном рекурсивном предикате, который осуществляет стратегию поиска. В целом, подробно останавливаться на работе каждого из предикатов не буду, так как всё это было подробно рассказано на лекции.
## Результаты
```prolog
?- depth_search([[k,k,k,m,m,m,b],[]], [[],[k,k,k,m,m,m,b]]).

[[k,k,k,m,m,m,b],[]]
[[k,k,m,m],[k,m,b]]
[[k,k,m,m,m,b],[k]]
[[k,k],[k,m,m,m,b]]
[[k,k,m,m,b],[k,m]]
[[k,m],[k,k,m,m,b]]
[[k,m,m,m,b],[k,k]]
[[k],[k,k,m,m,m,b]]
[[k,m,b],[k,k,m,m]]
[[],[k,k,k,m,m,m,b]]

Time is 0.0008220672607421875
true .

?- breadth_search([[k,k,k,m,m,m,b],[]], [[],[k,k,k,m,m,m,b]]).

[[k,k,k,m,m,m,b],[]]
[[k,k,m,m],[k,m,b]]
[[k,k,m,m,m,b],[k]]
[[k,k],[k,m,m,m,b]]
[[k,k,m,m,b],[k,m]]
[[k],[k,k,m,m,m,b]]
[[k,m,b],[k,k,m,m]]
[[],[k,k,k,m,m,m,b]]

Time is 0.0045053958892822266
true .

?- iter_search([[k,k,k,m,m,m,b],[]], [[],[k,k,k,m,m,m,b]]).

[[k,k,k,m,m,m,b],[]]
[[k,k,m,m],[k,m,b]]
[[k,k,m,m,m,b],[k]]
[[k,k],[k,m,m,m,b]]
[[k,k,m,m,b],[k,m]]
[[k],[k,k,m,m,m,b]]
[[k,m,b],[k,k,m,m]]
[[],[k,k,k,m,m,m,b]]

Time is 0.005402088165283203
true .
```

## Выводы
Все три алгоритма справились со своей задачей, однако самым эффективным оказался поиск в глубину. Неизвестно, насколько правильно замеряется время предикатом get_time(), но если исходить из результатов, поиск в глубину нашел путь на порядок быстрее. Это связано с тем, что вариантов решения, ровно как и вариантов перехода, достаточно много, и дерево решений получается большим. В таком случае, быстрее пройти по одной ветке с решением, возвращаясь только в случае неуспеха. Поэтому, в случае, если необходимо быстрое, но не самое оптимальное решение, алгоритм поиска в глубину подходит лучше других. Анализируя поиск в ширину, видно, что он имеет экспоненциальную сложность как по времени, так и по памяти, что, в некоторых случаях, может привести к переполнению стека. В случае же поиска в глубину с итеративным погружением, можно сказать, что он является некой модификацией поисков в ширину и глубину, включающей в себя их сильные стороны.
Для различных задач подходят различные виды поиска, и выбор должен зависеть от цели. В условиях ограничения по памяти лучше использовать поиск в глубину, а с целью поиска кратчайшего пути -- поиск в ширину. Поиск с итеративным углублением хоть и избегает экспоненциальной сложности, но пригоден только для самых простых задач. Конечно, лучше всего использовать эвристический поиск, что чаще и делают на практике.




